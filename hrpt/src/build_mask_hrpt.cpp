
#include <c_lib/c_types.hpp>
#include <hrptconst.hpp>

/*---------------------------------------------------------------------
	build_mask_hrpt
	Функция, аналогичная старой функции build_mask. Предназначена для
	вычисления длины кадра hrpt по маске hrpt.

	Кроме этого, функция вычисляет массив смещений для каждого поля hrpt
	в зависимости от заданной маски. Массив смещений задается как
	переменная hprt_disp[18] типа int. Каждый элемент
	этого массива задает смещение соответствующего маске поля в кадре
	входного файла ( смещение >= 0 ). Если поле отсутствует в кадре,
	элемент массива, соответствующий этому полю, имеет значение -1.
	Все поля в кадре обрабатываются по порядку. Порядок следования
	полей задан во второй части файла hrpt.h. Первым полем в кадре
	считается поле IDN, а последним - поле FSY ( это не совсем
	соответствует константам маски, описанным в первой части файла hrpt.h ).
	Для единоообразной обработки всех полей кадра hrpt введены локальные
	статические массивы, определенные через константы кадра hrpt.

	Также функция вычисляет количество каналов AVHRR во входном файле.
	Это значение необходимо для выделения отдельных каналов из битового
	потока, в котором все имеющиеся каналы чередуются ( т.н. interleaving ).
	Значение передается в функцию main через переменную channel_c.

---------------------------------------------------------------------*/
unsigned short build_mask_hrpt ( uint32_t mask, int* hrpt_disp, uint16_t* channel_c ) {
	int i;
	int j;
	static unsigned short m_len[15] = { LIDN, LTCD, LTLM, LBSC,
		LSPC, LHSY, LTIP-LTNO, LSPR, LAVHRR, LAVHRR, LAVHRR, LAVHRR,
		LAVHRR, LASY, LFSY };
	static unsigned long def_masks[15] = { MIDN, MTCD, MTLM, MBSC,
		MSPC, MHSY, MTIP, MSPR, M1, M2, M3, M4, M5, MASY, MFSY };
	unsigned short d;

	/* проходим по всем полям кадра, отмечаем отсутствующие поля,
	вычисляем смещения */
	d = 0;	/* начальное смещение для первого поля равно 0 */
	for ( i = 0; i < 15; i++ ) {
		/* если поле присутствует */
		if ( mask & def_masks[i] ) {
			/* записываем в поле накопленное значение смещения */
			hrpt_disp[i] = (int)d;
			/* и увеличиваем смещение для следующего поля */
			d += m_len[i];
		}
		else {	/* если текущее поле отсутствует, просто отмечаем поле
				 как отсутствующее; текущее накопленное смещение не меняется */
			hrpt_disp[i] = - 1;
		}
	}

	/* находим смещение первого присутствующего в файле канала AVHRR;
	отметим, что каналы AVHRR занимают в массиве hrpt_disp по порядку
	элементы с 8 по 12 включительно; это следует из определения
	статического массива def_masks */
	for ( i = 0; i < 5; i++ ) {
		if ( hrpt_disp[i+8] != - 1 ) {
			j = hrpt_disp[i+8];
			break;
		}
	}
	/* корректируем	смещения каналов AVHRR с учетом interleaving'а;
	заодно считаем количество каналов AVHRR */
	(*channel_c) = 0;
	for ( i = 0; i < 5; i++ ) {
		if ( hrpt_disp[i+8] != - 1 ) {
			hrpt_disp[i+8] = j;
			j++;	/* смещения всех каналов отличаются на 1 слово */
			(*channel_c)++;
		}
	}

	/* минимальную длину кадра в этом варианте программы вычислять не нужно;
	она уже вычислена в переменной d после окончания цикла */
	/* увеличиваем ее до числа, кратного 8 */
	while ( d & 7 ) d++;
	return d;
}
